import{r as p,B as D,j as e,T as Z,C as Q,g as F}from"./index-CFCNzs1K.js";import{B as J}from"./BackButton-DGavT3Uk.js";import"./Button-DVfOFneK.js";var G=function(){return(G=Object.assign||function(t){for(var a,r=1,s=arguments.length;r<s;r++)for(var n in a=arguments[r])Object.prototype.hasOwnProperty.call(a,n)&&(t[n]=a[n]);return t}).apply(this,arguments)},I,S,L=p.createContext(void 0),R="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML",q="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js",O=function(l){var a=l.config,r=l.version,r=r===void 0?3:r,s=l.src,s=s===void 0?r===2?R:q:s,n=l.onStartup,P=l.onLoad,f=l.asyncLoad,u=f!==void 0&&f,y=l.onError,f=l.typesettingOptions,A=l.renderMode,A=A===void 0?"post":A,k=l.hideUntilTypeset,l=l.children,i=p.useContext(L);if(i?.version!==void 0&&i?.version!==r)throw Error("Cannot nest MathJaxContexts with different versions. MathJaxContexts should not be nested at all but if they are, they cannot have different versions. Stick with one version of MathJax in your app and avoid using more than one MathJaxContext.");if(r===2&&S!==void 0||r===3&&I!==void 0)throw Error("Cannot use MathJax versions 2 and 3 simultaneously in the same app due to how MathJax is set up in the browser; either you have multiple MathJaxContexts with different versions or you have mounted and unmounted MathJaxContexts with different versions. Please stick with one version of MathJax in your app. File an issue in the project Github page if you need this feature.");var C=p.useRef(i),i=p.useRef(i?.version||null);if(i.current===null)i.current=r;else if(i.current!==r)throw Error("Cannot change version of MathJax in a MathJaxContext after it has mounted. Reload the page with a new version when this must happen.");var h=s||(r===2?R:q);function w(d,x){a&&(window.MathJax=a);var m=document.createElement("script");m.type="text/javascript",m.src=h,m.async=u,m.addEventListener("load",function(){var j=window.MathJax;n&&n(j),d(j),P&&P()}),m.addEventListener("error",function(j){return x(j)}),document.getElementsByTagName("head")[0].appendChild(m)}return C.current===void 0&&(i={typesettingOptions:f,renderMode:A,hideUntilTypeset:k},r===2?I===void 0&&(typeof window<"u"?(I=new Promise(w)).catch(function(d){if(!y)throw Error("Failed to download MathJax version 2 from '".concat(h,"' due to: ").concat(JSON.stringify(d)));y(d)}):(I=Promise.reject()).catch(function(d){})):S===void 0&&(typeof window<"u"?(S=new Promise(w)).catch(function(d){if(!y)throw Error("Failed to download MathJax version 3 from '".concat(h,"' due to: ").concat(d));y(d)}):(S=Promise.reject()).catch(function(d){})),C.current=G(G({},i),r===2?{version:2,promise:I}:{version:3,promise:S})),D.createElement(L.Provider,{value:C.current},l)},v=function(){return(v=Object.assign||function(t){for(var a,r=1,s=arguments.length;r<s;r++)for(var n in a=arguments[r])Object.prototype.hasOwnProperty.call(a,n)&&(t[n]=a[n]);return t}).apply(this,arguments)},z=function(t,a){var r={};for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&a.indexOf(n)<0&&(r[n]=t[n]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,n=Object.getOwnPropertySymbols(t);s<n.length;s++)a.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(t,n[s])&&(r[n[s]]=t[n[s]]);return r},E=function(t){return"Typesetting failed: ".concat(t.message!==void 0?t.message:JSON.stringify(t))},o=function(t){function a(){var b;w==="every"&&m&&d==="post"&&i.current!==null&&(i.current.style.visibility=(b=(b=l.style)==null?void 0:b.visibility)!=null?b:"visible"),j.current||(w==="first"&&i.current!==null&&(i.current.style.visibility="visible"),n&&n(),j.current=!0),P&&P(),T.current=!1}var s=t.inline,r=s!==void 0&&s,s=t.hideUntilTypeset,n=t.onInitTypeset,P=t.onTypeset,u=t.text,y=t.dynamic,f=t.typesettingOptions,A=t.renderMode,k=t.children,l=z(t,["inline","hideUntilTypeset","onInitTypeset","onTypeset","text","dynamic","typesettingOptions","renderMode","children"]),C=p.useRef(""),i=p.useRef(null),h=p.useContext(L),w=s??h?.hideUntilTypeset,d=A??h?.renderMode,x=f??h?.typesettingOptions,m=y!==!1&&(y||!1),j=p.useRef(!1),T=p.useRef(!1);return!T.current&&i.current!==null&&m&&w==="every"&&d==="post"&&(i.current.style.visibility="hidden"),(typeof window<"u"?p.useLayoutEffect:p.useEffect)(function(){if((m||!j.current)&&i.current!==null){if(!h)throw Error("MathJax was not loaded, did you use the MathJax component outside of a MathJaxContext?");if(d==="pre"){if(!(typeof(b=u)=="string"&&0<b.length))throw Error(`Render mode 'pre' requires text prop to be set and non-empty, which was currently "`.concat(u,'"'));if(!f||!f.fn)throw Error("Render mode 'pre' requires 'typesettingOptions' prop with 'fn' property to be set on MathJax element or in the MathJaxContext");if(h.version===2)throw Error("Render mode 'pre' only available with MathJax 3, and version 2 is currently in use")}d!=="post"&&u===C.current||T.current||(T.current=!0,h.version===3?h.promise.then(function(c){var M;d==="pre"?(M=function(g){C.current=u,c.startup.document.clear(),c.startup.document.updateDocument(),i.current!==null&&(i.current.innerHTML=g.outerHTML),a()},f.fn.endsWith("Promise")?c.startup.promise.then(function(){return c[x.fn](u,v(v({},x?.options||{}),{display:!r}))}).then(M).catch(function(g){throw a(),Error(E(g))}):c.startup.promise.then(function(){var g=c[x.fn](u,v(v({},x?.options||{}),{display:!r}));M(g)}).catch(function(g){throw a(),Error(E(g))})):c.startup.promise.then(function(){return c.typesetClear([i.current]),c.typesetPromise([i.current])}).then(a).catch(function(g){throw a(),Error(E(g))})}).catch(function(c){throw a(),Error(E(c))}):h.promise.then(function(c){c.Hub.Queue(["Typeset",c.Hub,i.current]),c.Hub.Queue(a)}).catch(function(c){throw a(),Error(E(c))}))}var b}),D.createElement("span",v({},l,{style:v(v({display:r?"inline":"block"},l.style),{visibility:w?"hidden":(t=l.style)==null?void 0:t.visibility}),ref:i}),k)};const W="/assets/CylindricalProjection-C7EBLVL6.png",V="/assets/CylindricalProjectionSideView-BknCN4cP.png",Y="/assets/CylindricalProjectionTopView-DkoTrdrs.png",H="/assets/ErrorDistributionMap(1920_1080image)-BE4t38V-.png",X="data:image/png;base64,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",N="data:image/png;base64,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",K="/assets/ImprovedReprojectionProcess-BchsTM3s.png",U="/assets/PhotoAfterDistortionCorrection-C8shuWI1.png",B="/assets/PhotoBeforeDistortionCorrection-CRGbfjpj.png",$="/assets/PinholeCameraModel-C3uNbS_S.jpg",_="data:image/png;base64,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",ee="/assets/ReprojectionProcess-VHJu24Co.png";function ne(){return p.useLayoutEffect(()=>{window.scrollTo(0,0)}),e.jsxs("div",{className:"project-page",children:[e.jsx(J,{}),e.jsxs(Z,{style:{fontSize:20,color:Q},children:[e.jsx("h1",{style:{color:F,marginTop:30},children:"Camera Calibration and Distortion Correction"}),e.jsx("div",{children:"Fisheye camera is widely used in the self-driving vehicles fields due to it can provide a bigger view. However, it brings image distortion problems. So we need to find a proper way to solve this problem."}),e.jsxs("ul",{children:[e.jsx("li",{style:{marginBottom:4},children:"Through processed video flows of camera sensors for self-driving vehicles with camera calibration and distortion correction algorithms, we can mitigate the side effects."}),e.jsx("li",{style:{marginBottom:4},children:"In addition, we achieved a reduction of distortion correction errors from 1.395 ± 0.136 pixels to 0.055 ± 0.192 pixels through cylindrical projection and single-point mapping with Python"}),e.jsx("li",{style:{marginBottom:4},children:"Based on these results, I developed a mapping table and video processing algorithms for digital signal processors with C based on OpenCV to increase the processing efficiency of DSP (Digital Signal Processor)."})]}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:B,width:"30%",alt:"Before distortion correction"}),e.jsx("div",{style:{width:"5%",display:"inline-block"}}),e.jsx("img",{src:U,width:"30%",alt:"After distortion correction"}),e.jsx("div",{style:{height:10}}),e.jsxs("div",{className:"figure-footnote",children:["An example of photo before/after distortion correction"," "]})]}),e.jsx("br",{}),e.jsx("hr",{}),e.jsx("br",{}),e.jsxs(O,{children:[e.jsx("span",{children:"The following topics are discussed in this article:"}),e.jsxs("ul",{children:[e.jsx("li",{children:"The principle and implementation of Calibration for pinhole camera model and fisheye camera model"}),e.jsx("li",{children:"Further optimization using cylindrical projection and how to decrease pixel errors"}),e.jsx("li",{children:"Development of DSP mapping table"})]}),e.jsx("h3",{children:"1. Pinhole Camera Model"}),e.jsx("p",{children:"In the pinhole camera model, the imaging model can be simplified as shown in the following figure:"}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:$,width:"80%",alt:"Pinhole Camera Model"}),e.jsx("div",{className:"figure-footnote",children:"figure1.1 Pinhole camera model"})]}),e.jsx("p",{children:"where f is the focal length of the camera , Z is the distance from the camera to the object, X is the length of the object, and x is the image of the object on the image plane. Through the similar triangle relationship can be obtained:"}),e.jsx(o,{children:String.raw`$$
                                          \begin{cases}
                                          x=\frac{X}{Z}f\\
                                          y=\frac{Y}{Z}f
                                          \end{cases}
                                        $$`}),e.jsx("p",{children:"Since the center position is usually not on the optical axis due to accuracy problems, we introduce two new parameters cx and cy to model the possible offset of the projection screen coordinate center relative to the optical axis."}),e.jsxs("p",{children:["The book ",e.jsx("i",{children:"Learning OpenCV3"})," told us that according to projective geometry, the point Q of the physical world is projected to the point q on the camera plane, which can be expressed as",e.jsx(o,{children:String.raw`$$\vec{q} = M \cdot  \vec{Q}$$`}),e.jsx(o,{children:String.raw`$$
                                          \vec{q} = \left [ \begin{matrix}
                                          x\\ 
                                          y\\ 
                                          w
                                          \end{matrix} \right ]
                                          ,
                                          M = \left [ \begin{matrix}
                                          f_x & 0 & c_x\\ 
                                          0 & f_y & c_y\\ 
                                          0 & 0 & 1
                                          \end{matrix} \right ]
                                          ,
                                          \vec{Q} = \left [ \begin{matrix}
                                          X\\ 
                                          Y\\ 
                                          Z
                                          \end{matrix} \right ]
                                        $$`})]}),e.jsxs("p",{children:["Lens shape, assembly, imaging physical characteristics, and other factors may cause lens distortion. There are mainly two types of distortion for normal lenses: radial distortion and tangential distortion, they can be approximated by polynomials and can be adjusted by the following formulas respectively. Radial distortion",e.jsx(o,{children:String.raw`$$
                                          \begin{cases}
                                          x_d = x(1+k_1r^2+k_2r^4+k_3r^6)\\
                                          y_d = y(1+k_1r^2+k_2r^4+k_3r^6)
                                          \end{cases}
                                        $$`}),"Tangential distortion",e.jsx(o,{children:String.raw`$$
                                          \begin{cases}
                                          x_d = x + [2p_1xy+p_2(r^2+2x^2)] \\
                                          y_d = y + [p_1(r^2+2x^2)+2p_2xy]
                                          \end{cases}
                                        $$`})]}),e.jsx("h3",{children:"2. Fisheye Camera Model"}),e.jsx("p",{children:"However, in the field of self-driving and visual slam, fisheye lenses and wide-angle lenses are applied more than the normal ones. The lenses we use are similar to fisheye lenses, but they are not exactly the same. We can refer to the fisheye camera model to build our model."}),e.jsx("p",{children:"Let P be a 3D point in the world reference coordinate system X. In the camera reference coordinate system, the vector coordinates of P are:"}),e.jsx(o,{children:String.raw`$$ X_C = RX + T $$`}),e.jsx("p",{children:"where R is the rotation matrix, and the coordinates x, y, and z of the three dimensions of Xc can be expressed as:"}),e.jsx(o,{children:String.raw`$$
                                          x = X_{C1} \\
                                          y = X_{C2} \\
                                          z = X_{C3}
                                          $$
                                          `}),e.jsx("p",{children:"The coordinates of P in the pinhole camera model are [a, b] "}),e.jsx(o,{children:String.raw`$$
                                        a=\frac{x}{z}\\
                                        b=\frac{y}{z} \\
                                        r^2 = a^2 + b^2 \\
                                        \theta = atan(r)
                                        $$`}),e.jsx("p",{children:"The distoration of the fisheye model is:"}),e.jsx(o,{children:String.raw`$$ \theta_d = \theta(1+k_1\theta^2+k_2\theta^4+k_3\theta^6+k_4\theta^8) $$`}),e.jsx("p",{children:"Distoration coordinates [x',y']："}),e.jsx(o,{children:String.raw`$$
                                        x' = a \frac{\theta_d}{r}\\
                                        y' = b \frac{\theta_d}{r}
                                        $$`}),e.jsx("p",{children:"Finally, convert to the pixel coordinate system, the final pixel coordinate [u,v] would be:"}),e.jsx(o,{children:String.raw`$$
                                        u = f_x (x'+αy' )+c_x \\
                                        v = f_y y'+c_y
                                        $$`}),e.jsxs("p",{children:["In all, to achieve camera calibration, we need to solve the following parameters:"," "]}),e.jsxs("ul",{children:[e.jsxs("li",{children:["four camera intrinsic parameters:",e.jsx(o,{children:String.raw`$$(f_x,f_y,c_x,c_y)$$`})]}),e.jsxs("li",{children:["five (or more) distortion parameters",e.jsxs("ul",{children:[e.jsxs("li",{children:["composed of three(or more) is composed of radial parameters",e.jsx(o,{children:String.raw`$$(k_1,k_2,k_3 [,k_4,k_5,k_6])$$`})]}),e.jsxs("li",{children:["two tangential parameters",e.jsx(o,{children:String.raw`$$(p_1, p_2)$$`})]})]})]})]}),e.jsx("p",{children:"Due to the coupling between intrinsic and extrinsic parameters, we will need multiple views to solve them."}),e.jsxs("p",{children:["OpenCV provides us the function ",e.jsx("pre",{children:"cv::calibrateCamera()"})," to find a close distortion parameters and get the closed-loop solution. And then we can apply LM optimization to re-estimate the internal and external parameters to get a better solution."]}),e.jsxs("p",{children:["After that, we can use the ",e.jsx("pre",{children:"initUndistortRectifyMap()"})," and the parameters we achieved to distort the correction."]}),e.jsx("p",{children:"Figure 2.1 and figure 2.2 show an example of the result of distortion correction."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:B,width:"40%",alt:"Before distortion correction"}),e.jsxs("div",{className:"figure-footnote",children:["figure2.1 Photo before distortion correction"," "]})]}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:U,width:"40%",alt:"After distortion correction"}),e.jsxs("div",{className:"figure-footnote",children:["figure2.2 Photo after distortion correction"," "]})]}),e.jsx("h3",{children:"3. Cylindrical Projection"}),e.jsx("p",{children:"The camera we used is similar to the fisheye camera. Although using the fisheye model for calibration and distortion correction can get good results, there is still great stretching on the sides of the picture, especially in the video stream."}),e.jsx("p",{children:"Since the vehicles in the images used for training the recognition model are in an unstretched state, the detection of the distortion-corrected image will have a certain impact on the detection results. Therefore, it is necessary to compress the image locally to make the vehicle model close to the test. We can achieve this by cylindrical projection."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:W,width:"30%",alt:"Cylindrical projection"}),e.jsxs("div",{className:"figure-footnote",children:[" ","figure3.1 Cylindrical projection"," "]})]}),e.jsx("p",{children:"Assuming that the camera model is a pinhole camera model, and the camera is located at N, as shown in the figure. The image we got from the camera is a rectangular plane EFGH. If we project the rectangular plane EFGH onto a cylindrical surface, it would become a curved surface like JDILCK. We need to find the correspondence of each pixel from the rectangular plane EFGH to the projected surface JDILCK."}),e.jsx("p",{children:"Let the focal length of the camera be f (f can take any value, not necessarily the real value that requires the focal length of the camera), take the center in the original image EFGH (W/2,H/2) is the origin."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:Y,width:"40%",alt:"figure3.2 Cylindrical projection top view"}),e.jsxs("div",{className:"figure-footnote",children:[" ","figure3.2 Cylindrical projection top view"," "]})]}),e.jsx("p",{children:"Figure 3.2 shows the top view of cylindrical projection. The point -W/2 is mapped to -W'/2, and the point W/2 is mapped to W'/2. As we set the direction from -W/2 to W/2 as the X direction of the original image, the direction from -W'/2 to O to W'/2 would be the X direction of the projected cylindrical surface."}),e.jsxs("p",{children:["Let's assume that there is a point x on the original plane, which is mapped to x' on the surface. Let",e.jsx(o,{children:String.raw`$\angle xNO = \theta$`}),"then",e.jsx(o,{children:String.raw`$$
                  \theta=arctan⁡(\frac{x}{f})
                  $$`}),"The arc length",e.jsx(o,{children:String.raw`$$
                  x'= f \times \theta
                  $$`}),"Therefore, the relationship of the cylindrical projection mapping in the X-axis direction would be",e.jsx(o,{children:String.raw`$$
                  x'=f \times arctan⁡(\frac{x}{f})
                  $$`}),"Figure3.3 is the side view. The red dotted line in the side view (figure3.3) corresponds to the red dotted line in the top view (figure3.2). We can get the following relationship.",e.jsx(o,{children:String.raw`$$
                  xN=\frac{f}{cos\theta}
                  $$`}),"And from the similar triangular, we can get",e.jsx(o,{children:String.raw`$$
                  \frac{y}{\frac{f}{cos\theta}} = \frac{y'}{f}
                  $$`})]}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:V,width:"30%",alt:"figure3.2 Cylindrical projection side view"}),e.jsxs("div",{className:"figure-footnote",children:["figure3.3 Cylindrical projection side view"," "]})]}),e.jsxs("p",{children:["In all, the corresponding relationship of each pixel between the original image and the projection surface is as follows:"," "]}),e.jsx(o,{children:String.raw`$$
                \theta=arctan⁡(\frac{x}{f})\\
                x'= f \times \theta\\
                \frac{y}{\frac{f}{cos\theta}} = \frac{y'}{f}
                $$`}),e.jsx("p",{children:"As "}),e.jsx(o,{children:String.raw`$$ x=x'-x_{center}\\
                y=y'-y_{center} \\
                x'=x_{reverse}-x_{center} \\
                y'=y_{reverse}-y_{center}\\
                $$ `}),e.jsx("p",{children:"The inverse function would be: "}),e.jsx(o,{children:String.raw`$$
                x_{reverse} = f \times tan(\frac{x'-x_{center}}{f}) + x_{center}\\
                \theta = arctan(\frac{x_{reverse}-x_{center}}{f})\\
                y_{reverse}  = cos\theta \cdot (y' -y_{center}) + y_{center}
                $$`}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:ee,width:"60%",alt:"figure3.4 Reprojection process"}),e.jsxs("div",{className:"figure-footnote",children:["figure3.4 Reprojection process"," "]})]}),e.jsxs("p",{children:["We use the D as the evaluation standard of pixel error, where D is"," "]}),e.jsx(o,{children:String.raw`$$ D= \sqrt{(x-reverse_x)^2+(y-reverse_y)^2} $$`}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:_,width:"40%",alt:"figure3.5 Reprojection pixel error result"}),e.jsx("div",{className:"figure-footnote",children:"figure3.5 Reprojection pixel error result"})]}),e.jsx("p",{children:"The result is shown in figure 3.5. It shows that for an image with a size of 1920*1080 and a total of 2,073,600 pixels, most of the point pixel errors are within the error range of 1 pixel ~ 2 pixel, with an average value of 1.395 ± 0.136 pixel."}),e.jsxs("table",{children:[e.jsxs("tr",{children:[e.jsx("th",{children:"Pixel error (pixel)"}),e.jsx("th",{children:"number"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"D = 0"}),e.jsx("td",{children:"5337"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"0 < D < 1"}),e.jsx("td",{children:"0"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"1 < D < 2"}),e.jsx("td",{children:"2053524"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"2 < D < 3"}),e.jsx("td",{children:"14739"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:" D > 3"}),e.jsx("td",{children:"0"})]}),e.jsx("tr",{children:e.jsx("span",{children:"sum: 1.395 ± 0.136 pixel"})})]}),e.jsx("p",{children:"Considering that in the calculation process of the mapping table, linear interpolation was applied which may cause the error in the reprojection process. In order to reduce the error, we build the mapping table for mapping the original image to distortion correction image directly without interpolation and other steps and retain the decimal part. Then applied the cylindrical projection coordinate transformation to achieve the mapping table from the original image to the cylindrical projection image. We back-project it and compare the result with the mapping table of the distortion correction image."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:K,width:"70%",alt:"figure3.6 Imporved reprojection process"}),e.jsx("div",{className:"figure-footnote",children:"figure3.6 Imporved reprojection process"})]}),e.jsx("p",{children:"The process is shown in figure3.6. (map1, map2) is the mapping table from the original image to the distortion correction image.(cylinder_project_map1, cylinder_project_map2) is the mapping table from the original image to the cylindrical projection image.(reserve_map1, reserve_map2) is the original image through the cylindrical projection Back-projected back to the mapping table of the distortion map. For any pixel on the cylindrical projection map, we can find the corresponding pixel in the original image through (cylinder_project_map1, cylinder_project_map2), and then find its undistortion pixel."}),e.jsx("p",{children:"The result is 1.822 ± 49.143 pixel, which is even worse than the previous back-projection method. But we found that there will be a pixel offset for all points. If we try to correct it, the outermost pixel will have the problem that there would be no corresponding mapping point. Fortunately, the target detection is mainly concentrated in the center of the image, and the influence of edge points is relatively small. Therefore, we can just remove the pixels in the outermost, and correct the offset, the error is reduced to 0.055 ± 0.192 pixel."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:X,width:"50%",alt:"Improved reprojection pixel error result (before/after processing offset, 1920*1080)"}),e.jsx("div",{className:"figure-footnote",children:"figure3.7 Improved reprojection pixel error result (before/after processing offset, 1920*1080 image)"})]}),e.jsx("p",{children:"And the error distribution map would be like figure3.8."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:H,width:"70%",alt:"Error distribution map (1920*1080)"}),e.jsx("div",{className:"figure-footnote",children:"figure3.8 Error distribution map (1920*1080 image)"})]}),e.jsx("p",{children:"When the image size is 3420*1200, the result would be:"}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:N,width:"50%",alt:"Improved reprojection pixel error result (before/after processing offset, 3420*1200)"}),e.jsx("div",{className:"figure-footnote",children:"figure3.9 Improved reprojection pixel error result (before/after processing offset, 3420*1200 image)"})]}),e.jsxs("p",{children:["It is worth noting that figure3.8 shows the center pixels of the image, which are the pixel point errors on the (x_center ,y) coordinate are greater than 1 pixel. According to above formula, there should have x_reverse=x_center and y_reverse=y_center at the center of the image. If we just modify the reverse mapping table directly. The error will be even larger."," "]}),e.jsx("p",{children:"After analysis, this may caused by the fractional part of the distortion correction mapping table.Due to the influence of the fractional part, the statistical error will bring more errors. And it needs further analysis."}),e.jsx("h3",{children:"4. DSP Development"}),e.jsx("p",{children:"After obtaining the internal and external parameters of the camera, it is necessary to perform the projective transformation on each pixel in the original image to achieve distortion correction image. We can store the undistorted coordinates corresponding to each pixel as a mapping table. The mapping table of each camera will be initialized only once, and we can speed up operational efficiency by just looking for corresponding coordinates through the mapping table as it will save time for calculation."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:N,width:"50%",alt:"Improved reprojection pixel error result (before/after processing offset, 3420*1200)"}),e.jsx("div",{className:"figure-footnote",children:"figure3.9 Improved reprojection pixel error result (before/after processing offset, 3420*1200 image)"})]}),e.jsx("p",{children:"DSP uses the YUV format which is 4:2:0 sampling. This sampling format can save a lot of storage space compared to RGB. As shown in the figure4.2, only one chrominance component is stored at a 2:1 sampling rate for each scan line, and adjacent scan lines will store different chrominance components. Each time a pixel is sampled, the Y component will be sampled, and the U and V components will be sampled 2:1 interlaced. Compared with RGB, this sampling method saves general storage space."}),e.jsxs("div",{className:"figure",children:[e.jsx("img",{src:N,width:"50%",alt:"Improved reprojection pixel error result (before/after processing offset, 3420*1200)"}),e.jsx("div",{className:"figure-footnote",children:"figure3.9 Improved reprojection pixel error result (before/after processing offset, 3420*1200 image)"})]}),e.jsx("p",{children:"At the same time, the maximum pixels processed by the DSP at one time are 256*256, while the size of our input image is 1920*1080, which is much larger than its limit. Therefore, we need to divide the mapping table to meet the requirements of the largest pixel processed by the DSP. In addition, in order to enable the DSP to perform distortion correction, the mapping table needs to be output as a binary file that can be used by the DSP according to a certain format."}),e.jsx("span",{children:"The whole process will be the following steps:"}),e.jsxs("ol",{children:[e.jsx("li",{children:"Generating the mapping table array according to the camera internal and external parameters, input image size, output image size, and other parameters"}),e.jsx("li",{children:"Extract the Y component and UV component from the mapping table array"}),e.jsx("li",{children:"Determine the size range of the image segmentation, and segment the image to obtain the segmentation size of the Y component and UV component, the coordinate point of the upper left corner of each segment, and the length and width of the maximum segmentation."}),e.jsx("li",{children:"Output as binary file according to DSP processing format requirements"})]}),e.jsxs("table",{children:[e.jsxs("tr",{children:[e.jsx("th",{}),e.jsx("th",{children:"Parameter Type"}),e.jsx("th",{children:"Input Parameter"}),e.jsx("th",{children:"Output Parameter"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"Internal parameters"}),e.jsx("td",{children:"double / float"}),e.jsx("td",{children:"fx, fy, cx, cy"}),e.jsx("td",{})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"Distortion parameter"}),e.jsx("td",{children:"double / float"}),e.jsx("td",{children:"k1, k2, k3, k4"}),e.jsx("td",{})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"Original Image Resolution"}),e.jsx("td",{children:"int"}),e.jsx("td",{children:"(width, height)"}),e.jsx("td",{})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"Output Image Resolution"}),e.jsx("td",{children:"int"}),e.jsx("td",{children:"(width, height)"}),e.jsx("td",{})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"Binary file for DSP"}),e.jsx("td",{}),e.jsx("td",{}),e.jsx("td",{children:"Binary file"})]})]})]})]})]})}export{ne as default};
